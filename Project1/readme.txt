საშინაო დავალება OS 2016 Fall კლასისთვის.
FreeShell

პროექტზე მუშაობდნენ:
ნიკოლოზ დონაძე - TheDonsky
ბექა მაისურაძე - BekaMaisuradze
ირაკლი ხადური - IKhaduri
დავით აკოპოვი - dav23r

გარე ბიბლიოთეკა და მისი დაყენება:
ბიბლიოთეკა - readline
დაყენება -  sudo apt-get install libreadline6 libreadline6-dev

გამოყენება:

გაშვება - make && ./FreeShell

ფუნქციონალი:
ეს არის unix shell-ის შემცირებულ ფუნქციონალიანი იმპლემენტაცია.
აქ შემდეგი ბრძანებების გაშვება შეიძლება:
1)ნებისმიერი ფუნქციის რომელსაც executable აქვს Path ცვლადში მითითებულ
დირექტორიებში. 
მაგ: ls -l
firefox google.com
cheese

2) შელის ჩაშენებულ ფუნქციებს
	cd - ცვლის დირექტორიას
მაგ : cd errors გადავა errors დირექტორიაში, რომელიც უნდა იყოს სამუშაო
დირექტორიაში.
	pwd - ბეჭდავს სამუშაო დირექტოიას, რომელშიც ახლა ვართ.(ეს გამოიყენება
ასევე მუდმივად შელის მუშაობისას, იწერება ჩვენი სამუშაო ადგილი.)
	exit  - ასრულებს პროცესს. exit -k მშობელ პროცესს უბრუნებს სტატუს კოდს
k-ს
	ulimit -  ბეჭდავს ან ცვლის ამ მომენტისთვის არსებულ სისტემურ ლიმიტებს.
მაგ: ulimit -a ბეჭდავს ყველა სისტემურ ლიმიტს. 
შეცვლის სინტაქსი - ulimit -S ან -H -(ფლეგი შესაბამისი ლიმიტის) რიცხვი
S-soft limit, H- hard limit. ნახეთ man ulimit მეტი ინფორმაციისთვის.
	kill -  კლავს პროცესს მოცემული pid-თი.
მაგ: kill 18 მოკლავს 18 pid-ს მქონე პროცესს.
	nice  - თუ nice-ს გამოვიძახებთ პარამეტრების გარეშე, დაბეჭდავს მიმდინარე 
პროცესის niceness-ს. -n პარამეტრით და რიცხვით, შემდგომ გადაცემულ ფუნქციას თავის
არგუმენტებიანად იძახებს ახალ პროცესად და გადაცემული რიცხვით ცვლის პრიორიტეტს.
მაგ: nice -n 10 firefox google.com 
	type  - ბეჭდავს რა ტიპისაა შემდგომ გადაცემული ფუნქცია, ანუ ჩაშენებულია
თუ სისტემური. -a ფლეგით ყველა ნაპოვნ გამშვებს ბეჭდავს.
	echo $VARNAME -- ბეჭდავს მითითებული ცვლადის მნიშვნელობა
	echo $? -- ბეჭდავს ბოლო შვილობილი პროცესის სტატუს კოდს
	echo "some random string" -- ბეჭდავს გადმოცემულ სტრინგს stdout-ზე
	export VARIABLE -- აექსპორტებს ცვლადს და მის მნიშვნელობას

3)არის დაწერილი პაიპების იმპლემენტაცია, ანუ ბრძანებათა გადაბმა შეიძლება.
მაგ ls /etc | grep passwd | sort
	ls-ის stdout გადაეცემა ინფუთად grep-ს და 
	grep-ის stdout გადაეცემა ინფუთად sort-ს.
არ არის გათვალისწინებული ფრჩხილები.

4)თუ ბრძანებები გადაბმულია ‘||’ ოპერატორით მარჯვენა ოპერანდი სრულდება მაშინ როცა 
მარცხენა ოპერანდი შედეგად დააბრუნებს არანულოვან კოდს(მუშაობას დაასრულებს შეცდომით).
თუ ბრძანებები გადაბმულია ‘&&’ ოპერატორით მარჯვენა ოპერანდი სრულდება მაშინ როცა 
მარცხენა ოპერანდი შედეგად დააბრუნებს 0-ს(მუშაობას დაასრულებს წარმატებით).
FreeShell გადაუყვება მარცხნიდან მარჯვნივ და პირველივე შემთხვევაზე, როდესაც
ან ||-იყო წარმატებული, ან && იყო წარუმატებელი, ასრულებს ინფუთის დამუშავებას.

5) პროგრამა არ კვდება exit-ის ან გარეგანად მოკვლის გარდა.

6) ოპერატორი ‘<’ ამისამართებს სტანდარტულ ინფუთს (stdin)
   ოპერატორი ‘>’ ამისამართებს სტანდარტულ აუთფუთს (stdout)
   ჯერ ფაილის ზომას ანულებს
   ოპერატორი ‘>>’ ამისამართებს სტანდარტულ აუთფუთს (stdout)
   ახალ მონაცემებს ბოლოში აწებებს
   მაგ: ბრძანება cat fsh.c > fsh_temp.txt
   fsh.c ფაილის შიგთავსი გადააქვს fsh_temp.txt ფაილში
   (fsh_temp.txt ფაილის ზომა დასაწყისში ნულდება)
7) ინახავს ბრძანებების ისტორიას, როგორც ნამდვილი შელი.

8)უშვებს executable ფაილებს რომელიც მოცემულ დირექტორიაშია,
./executable-file-name ბრძანებით.

9) ; გამოყოფს ერთმანეთისგან ბრძანებებს და მიმდევრობით ეშვება თითოეული
ახალ პროცესად ეშვება საჭიროებისდა მიხედვით.

10)-c პარამეტრის გადაცემისას შემდეგ რაც მოდის ერთ არგუმენტად იღებს
და უშვებს. FreeShell კვდება ამის შესრულების შემდეგ, ან შეიძლება ითქვას 
რომ არც კი ეშვება.

11)  Alias ბაშის ფუნქციონალი, იძლევა საშუალებას, რომ შელმა
დაიხსომოს ერთი ნებისმიერი ტოკენი და ჩაანაცვლოს თუ თავშია
ეს ტოკენი. ასევე მოშორებაც შეიძლება ამ ალიასის.

მოდულები:

arguments.h - არგუმენტების ტიპებს განსაზღვრავს, რაც ინფუთის დამუშავებისას
გამოიყენება.
context.c/.h - კონტექსტი იდეურად არის ჩვენი შელის მახასიათებელი ინფორმაცია
(მაგ ჩვენი environment variables) რომელიც გადაეცემა ფუნქციებს საჭირო
ინფორმაციისთვის.
fsh_alias.c/.h - აიმპლემენტირებს ბაშის built-in alias ფუნქციონალს
fsh_kill.c/.h, fsh_ulimit.c/.h, fsh_nice.c/.h აიმპლემენტირებენ
სახელის შესაბამისად kill, ulimit და  nice built-in ფუნქციონალს.
ნაისი ასევე გამოიყენება სხვა პროგრამების გასაშვებად.
fsh_unalias.c/.h - ალიასების განთAვისუფლებისთვის, წასაშლელად.
functions_runner.h/.c - პარსერის შემდეგ ყველაზე მნიშვნელოვანი ნაწილი,
დაპარსულ ინფუთს ამუშავებს და შესაბამის ფუნქციონალს იძახებს, იქნება ეს
built-in თუ უბრალო პროგრამა.
input_parser.c/.h - პარსავს ინფუთს, ტოკენებად ჭრის და გადასცემს 
functions_runner-ს. აქ არის იმპლემენტაცია პაიპებად დაჭრის და რეკურსიულად
გამოიძახების ყოველი შემდეგი პაიპის შიგთავსის. 
tokenizer.c/.h - აქ ხდება ნაწილებად დაჭრა ინფუთის, რომ შემდგომმა 
ფუნქციებმა სწორი არგუმენტები მიიღონ. ფლეგების და დაკომენტარებული(""-ში ჩასმული)
ნაწილების ამოცნობა აქ ხდება.
io_redir.c/.h - შელის მეექვსე ფუნქციონალი აქაა დაწერილი.
load_functions.c/.h - მეპში იყრება ყველა ბილთ-ინ ფუნქცია, შემდგომი
სწრაფი ინფორმაციის მიღებისთვის.
parser_exceptions.h/.c - -c ფლეგისთვის დაწერილი ფუნქციონალი, რადგან ამ
შემთხვევაში სხვანაირად უნდა დაიპარსოს სტრინგი. თუმცა კოდი საშუალებას იძლევა
რომ მარტივად დაემატოს სხვა გამონაკლისი წაკითხვის ინსტრუქციაც.
util.c./h - ფუნქციები რომლებიც სხვა ფაილებში ხშირად გამოიყენება: ერორების
დაბეჭდვა, სტრინგი ციფრებითაა ჩაწერილი თუ არა..
vector, hashset - დამხმარე სტრუქტურები.

 
main.c -> აქ იწყება FreeShell.   

პროექტი დაწერილია make-ის გამოყენებით, საჭირო ინსტრუქციები 
makefile-ში წერია.













 

























